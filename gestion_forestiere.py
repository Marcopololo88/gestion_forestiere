# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CoordClick
                                 A QGIS plugin
 Affichage coordonn√©es sur click souris
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-31
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Marc GROSJEAN
        email                : marc.grosjean@wanadoo.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

import time

from . import resources_rc

from qgis.PyQt.QtCore import (
    QSettings,
    QTranslator,
    QCoreApplication,
    QVariant,
    Qt,
    QDate,
    QTimer,
    QUrl,
    QThread,
)
from qgis.PyQt.QtGui import QIcon, QDesktopServices
from qgis.PyQt.QtWidgets import QAction,QTableWidgetItem
from qgis.gui import QgsMapToolEmitPoint
from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsFeature,
    QgsGeometry,
    QgsPointXY,
    QgsFeatureRequest,
    edit,
    QgsMessageLog,
    Qgis,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling,
    QgsRuleBasedLabeling,
    QgsPalLayerSettings,
    QgsTextFormat,
    QgsVectorLayer,
    QgsTextBufferSettings,
    QgsWkbTypes,
)
# Imports pour fen√™tre secondaire
from PyQt5.QtWidgets import (
    QApplication,
    QMessageBox,
    QTableWidgetItem,
    QHeaderView,
    QDialog,
)
from PyQt5.QtGui import QFont, QColor
from .coord_click_dialog import CoordClickDialog  # ta fen√™tre principale (h√©rite de QDialog + setupUi)
from .create_polygon_dialog_wrapper import CreatePolygonDialog
from datetime import datetime
from itertools import batched
# Importations des donn√©es de la table des donn√©es depuis fichier utils
from .utils import (
    safe_set_text,
    extract_table_values,
    unique_values_per_column,
    log_debug,
    log_warning,
    log_error,
    show_success_bar,
    format_date,
    get_valid_active_layer,
    get_valid_active_layer_start,
    show_error_bar,
    safe_str,
    load_table_from_csv,
    save_table_to_csv,
    get_fill_color_from_layer,
)

# importations fichier analyses.py
from .Analyse import (
    calcul_surface_forestiere,
    calcul_surface_friche,
    total_plantation,
    analyse_types_parcelles,
    export_to_excel,
    analyse_types_essences,
    calcul_regroupement,
    compter_parcelles_possedees,
)

# importations constantes

from .constantes import (
    TYPE_PARC_LIBELLES,
    SAISIE_COMBO_COUNTS,
    SAISIE_COMBO_SETTINGS,
)

from .analyse_worker import AnalyseWorker

# importations fichier config.py
from .param import ConfigDialog


#Import outil fill ring
from .fill_ring_tool import FillRingTool

#Importation fen√™tre gestion infos polygones
from .infos_polygon import InfosPolygonManager
from .create_polygon_dialog import Ui_createPolygonDialog

import os.path
import datetime


class FenetrePrincipale(CoordClickDialog):  # Fen√™tre principale, h√©rit√©e de CoordClickDialog en attente
    def __init__(self):
        super().__init__()
        print('fenetre principale')


class CoordClick:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        self.start_time = time.time()
        print("D√©but __init__")

        """Constructor.

        :param iface: An interface instance that will be passed to this class
        :type iface: QgsInterface
        """
        super().__init__()  #new
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = iface.mapCanvas()  #new

        # Initialisation du r√©pertoire plugin
        self.plugin_dir = os.path.dirname(__file__)
        self.first_start = True   #new
        # Cr√©ation de self.dlg
        self.dlg = CoordClickDialog()
        self.first_show = True
        self.last_position = None

        # Cr√©ation du dialog de configuration et passage de iface
        self.config_dialog = ConfigDialog(self.iface.mainWindow(), self.iface)
  # Passer 'iface' √† ConfigDialog

        # Cr√©ation de la bo√Æte de dialogue creation polygone
        self.create_polygon_dialog = QDialog()
        self.ui_create_polygon = Ui_createPolygonDialog()
        self.ui_create_polygon.setupUi(self.create_polygon_dialog)

        # D√©finir le chemin vers le fichier CSV
        self.csv_path = os.path.join(os.path.dirname(__file__), "table_data.csv")

        # Mise √† jour des combos √† chaque modification de la table
        self.dlg.tableWidgetData.itemChanged.connect(self.refresh_combos_from_table)

        # Connexion des combos
        self.connect_saisie_combos()

        # Initialisation des attributs
        self.current_feature_id = None
        self.first_show = True
        self.last_position = None

        # Rend les champs de l'onglet propri√©taire non modifiables
        self.dlg.nomProp.setReadOnly(True)
        self.dlg.lineAdress.setReadOnly(True)
        self.dlg.lineMail.setReadOnly(True)
        self.dlg.lineTel.setReadOnly(True)

        # initialise les variables pour analyse_worker
        self.analyse_results = None
        self.analyse_thread = None
        self.analyse_worker = None

        # Mettre les titres de colonnes en gras
        header = self.dlg.tableWidgetData.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.Stretch)
        font = header.font()
        font.setBold(True)
        header.setFont(font)

        # üîó Connexion de la case √† cocher au changement d'√©tat
        self.dlg.checkEditProp.stateChanged.connect(self.toggle_edit_mode)
        self.dlg.btnSaveProp.setEnabled(False)
        self.toggle_edit_mode()

        # Initialisation du r√©pertoire plugin
        self.plugin_dir = os.path.dirname(__file__)

        # R√©cup√©ration du canvas courant
        self.canvas = self.iface.mapCanvas()

        # Cr√©ation d'un outil √©mettant un point au clic
        self.point_tool = QgsMapToolEmitPoint(self.canvas)

        # Initialisation locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir, 'i18n', f'CoordClick_{locale}.qm')

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # D√©claration menu
        self.actions = []
        self.menu = self.tr(u'&Coordonn√©es sur click')


        # Connecte ma fen√™tre pour saisie des infos
        self.infos_polygon_manager = InfosPolygonManager(self.ui_create_polygon, self.create_polygon_dialog)


        # Initialisation de la case √† cocher et bouton enregistrer
        self.dlg.btnSaveProp.clicked.connect(self.save_proprietaire_info)

        # Initialisation de l‚Äô√©tat propri√©taire
        self.is_proprietaire = False

        # üîÅ Mise √† jour initiale et dynamique de la visibilit√© des onglets
        self.update_tab_visibility()
        self.dlg.checkBoxConfig.toggled.connect(self.update_tab_visibility)


        # üîÑ Connexion au changement de couche
        self.iface.currentLayerChanged.connect(self.on_current_layer_changed)


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CoordClick', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # Action principale - Gestion parcelles foresti√®res
        icon_path = os.path.join(self.plugin_dir,'icons', 'icon.png')
        self.action_main = QAction(QIcon(icon_path), self.tr('Gestion parcelles foresti√®res'), self.iface.mainWindow())
        self.action_main.triggered.connect(self.run)
        self.iface.addPluginToMenu(self.tr('Gestion parcelles foresti√®res'), self.action_main)
        self.iface.addToolBarIcon(self.action_main)

        # Action secondaire - Configuration Plugin
        icon2_path = os.path.join(self.plugin_dir,'icons', 'icon2.png')
        self.action_config = QAction(QIcon(icon2_path), self.tr('Configuration Plugin'), self.iface.mainWindow())
        self.action_config.triggered.connect(self.run_config_dialog)
        self.iface.addPluginToMenu(self.tr('Gestion parcelles foresti√®res'), self.action_config)
        self.iface.addToolBarIcon(self.action_config)

        # Action troisieme - Page aide au d√©marrage
        icon3_path = os.path.join(self.plugin_dir,'icons', 'icon3.png')
        self.action_helpgen = QAction(QIcon(icon3_path), self.tr('Lire Avant'), self.iface.mainWindow())
        self.action_helpgen.triggered.connect(self.open_help_gen)
        self.iface.addPluginToMenu(self.tr('Gestion parcelles foresti√®res'), self.action_helpgen)
        self.iface.addToolBarIcon(self.action_helpgen)

        # Liste des actions pour suppression dans unload()
        self.actions = [self.action_main, self.action_config, self.action_helpgen]

        layer = self.iface.activeLayer()
        if isinstance(layer, QgsVectorLayer) and layer.geometryType() == QgsWkbTypes.PolygonGeometry:
            try:
                # D√©sactivation du formulaire natif QGIS
                layer.editFormConfig().setSuppressForm(True)

                # Connexion au signal featureAdded pour ta gestion personnalis√©e
                layer.featureAdded.connect(self.infos_polygon_manager.on_feature_added)
            except Exception as e:
                QgsMessageLog.logMessage(f"Erreur lors de la connexion au signal featureAdded : {e}", "coord_click",
                                         level=Qgis.Warning)

        # Flag d'initialisation
        self.first_start = True



    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'Gestion parcelles foresti√®res'),
                action)
            self.iface.removeToolBarIcon(action)

        # D√©connexion du clic sur la carte (point_tool)
        try:
            self.point_tool.canvasClicked.disconnect(self.display_point)
        except Exception:
            pass


    def run(self):
        """Run method that performs all the real work"""

        # V√©rifie que la couche active est valide et contient les champs requis au d√©marrage

        start = time.perf_counter()

        layer = get_valid_active_layer_start(self.dlg)
        if not layer:
            return  # Stoppe le lancement du plugin si la couche est invalide


        self.layer = layer  # Enregistre la couche si valide


        # Met √† jour le nom de la couche dans l'interface
        self.dlg.lineLayerAct.setText(self.layer.name())  #new

        if self.first_start:
            self.first_start = False
            self.dlg = CoordClickDialog()



            # Affichage de la couche active dans le champ
            self.dlg.lineLayerAct.setText(self.layer.name())

            # Lancement de l'aide au plugin
            self.dlg.btnHelp.clicked.connect(self.open_help)

            #Remplir le combo Modif l√©gende A v√©rifier si utile
            self.remplir_combo_modif_legend()

        # Connexion du bouton About
            self.dlg.toolButtonAbout.clicked.connect(self.show_about)

            # Charger les donn√©es CSV dans la table au d√©marrage
            load_table_from_csv(self.dlg.tableWidgetData, self.csv_path)



            # # Appel de l'analyse directement au d√©marrage
            # self.data_analyse()
            # mid5 = time.perf_counter()
            # print(f"Temps apr√®s data_analyse : {mid5 - mid4:.3f} s")

            # Lancement de l'analyse en arri√®re-plan
            self.start_analyse_worker()
            print("Lancement de l'analyse en arri√®re-plan.")

            #Bouton de sauvegarde des donn√©es
            self.dlg.btnSaveData.clicked.connect(self.save_table_data)

            # Ensuite remplir tous les combos de saisie d'un coup
            for prefix, combo_base_name, column_index in SAISIE_COMBO_SETTINGS:
                self.populate_saisie_combos(prefix, combo_base_name, column_index)


            # Connecte la checkbox √† la m√©thode de gestion des champs
            self.dlg.checkEditProp.stateChanged.connect(self.toggle_edit_mode)
            # Connecte le bouton de sauvegarde
            self.dlg.btnSaveProp.clicked.connect(self.save_proprietaire_info)
            # Applique l'√©tat initial des champs (coch√©e ou pas) pour l'onglet Propri√©taire
            self.toggle_edit_mode()

            # Connexion du bouton d'enregistrement de l'onglet Saisie
            self.connect_enregistrement_boutons()

            # Connecte le signal pour cliquer sur la carte
            self.point_tool.canvasClicked.connect(self.display_point)

        # D√©finit coorclick comme outil actif
        self.canvas.setMapTool(self.point_tool)

        # Active les √©tiquettes d√®s le lancement
        self.afficher_labels_dynamiques_sur_couche()

        # Connexion des cases √† cocher pour l'export
        self.init_export_connections()

        end = time.perf_counter()
        print(f"Temps __init__ CoordClick : {end - start:.3f} s")

    def run_config_dialog(self):
        # R√©cup√©rer la couche active
        layer = self.iface.activeLayer()

        # V√©rifier si la couche est une couche vecteur au format .gpkg
        if not isinstance(layer, QgsVectorLayer):
            QMessageBox.warning(
                self.iface.mainWindow(),
                "Format non valide",
                "La couche s√©lectionn√©e n'est pas une couche vecteur.\n"
                "Merci de s√©lectionner une couche compatible."
            )
            return

        source = layer.source().lower().split("|")[0]

        _, ext = os.path.splitext(source)
        if ext != ".gpkg":
            QMessageBox.warning(
                self.iface.mainWindow(),
                "Format non valide",
                f"La couche s√©lectionn√©e est de type {ext}.\n"
                "Merci de la convertir au format .gpkg."
            )
            return

        # Cr√©er une instance de ConfigDialog et afficher la bo√Æte de dialogue
        self.config_dialog = ConfigDialog(self.iface.mainWindow(), self.iface)
        self.config_dialog.exec_()

    def start_analyse_worker(self):
        self.analyse_results = None  # on remet √† z√©ro les r√©sultats
        self.analyse_thread = QThread()
        self.analyse_worker = AnalyseWorker(self.layer)
        self.analyse_worker.moveToThread(self.analyse_thread)

        self.analyse_thread.started.connect(self.analyse_worker.run)
        self.analyse_worker.finished.connect(self.on_analyse_finished)
        self.analyse_worker.finished.connect(self.analyse_thread.quit)
        self.analyse_worker.finished.connect(self.analyse_worker.deleteLater)
        self.analyse_thread.finished.connect(self.analyse_thread.deleteLater)

        self.analyse_thread.start()

    def on_analyse_finished(self, results):
        self.analyse_results = results
        self.data_analyse()  # mettre √† jour l'interface avec les r√©sultats

    def init_ring_fill_button(self):
        button = self.dlg.btnRingFill

        if button is None:
            return

        # D√©connecter proprement sans masquer toutes les exceptions
        try:
            button.clicked.disconnect(self.activate_fill_ring_tool)
        except TypeError:
            pass  # Aucun slot connect√©, pas de souci

        # R√©cup√®re la couche active et instancie l'outil Fill Ring
        layer = self.iface.activeLayer()
        self.fill_ring_tool = FillRingTool(self.canvas, layer, self.on_fill_ring_completed)

        # Connecter le bouton √† l'activation de l'outil
        button.clicked.connect(self.activate_fill_ring_tool)

        # Appliquer la couleur au bouton
        button.setStyleSheet("background-color: yellow")

    def activate_fill_ring_tool(self):
        """Active l‚Äôoutil Fill Ring pour dessiner un anneau/polygone."""
        print("M√©thode activate_fill_ring_tool appel√©e")
        self.canvas.setMapTool(self.fill_ring_tool)
        print("Outil Fill Ring activ√©")

    def on_fill_ring_completed(self, geometry):
        print("G√©om√©trie cr√©√©e :", geometry.asWkt())

        # Appel de la bo√Æte de dialogue
        self.infos_polygon_manager.dlg.show()

    def show_about(self):
        QMessageBox.about(
            self.dlg,
            "√Ä propos du plugin",
            "üå≤ <b>Gestion foresti√®re</b> v1.01<br>"
            "¬© 2025 Marc GROSJEAN<br><br>"
            "Plugin d√©velopp√© pour QGIS.<br>"
            "Tous droits r√©serv√©s."
        )

    # Gestion des cases √† cocher de l'export dans l'onglet Analyses
    def init_export_connections(self):
        self.dlg.checkToutExport.toggled.connect(self.on_check_tout_export_toggled)
        self.dlg.checkTravExport.toggled.connect(self.on_check_specific_export_toggled)
        self.dlg.checkTraitExport.toggled.connect(self.on_check_specific_export_toggled)
        self.dlg.checkPrevExport.toggled.connect(self.on_check_specific_export_toggled)
        # Connexion du bouton export ici
        self.dlg.btnExport.clicked.connect(self.export_to_excel)
        # (optionnel) connexion pour la case ouvrir export
        self.dlg.checkOpenExport.toggled.connect(self.on_check_open_export_toggled)


    def on_current_layer_changed(self, layer):
        if isinstance(layer, QgsVectorLayer) and layer.geometryType() == QgsWkbTypes.PolygonGeometry:
            self.infos_polygon_manager.connect_to_layer(layer)


    def on_check_open_export_toggled(self, checked):
        pass

    def on_check_tout_export_toggled(self, checked):
        self.dlg.checkTravExport.setEnabled(not checked)
        self.dlg.checkTraitExport.setEnabled(not checked)
        self.dlg.checkPrevExport.setEnabled(not checked)
        if checked:
            self.dlg.checkTravExport.setChecked(False)
            self.dlg.checkTraitExport.setChecked(False)
            self.dlg.checkPrevExport.setChecked(False)

    def on_check_specific_export_toggled(self, checked):
        if checked:
            self.dlg.checkToutExport.setChecked(False)

    # Appel gestion export Excel
    def export_to_excel(self):
        export_to_excel(self)

    def open_help_gen(self):
        help_path = os.path.join(os.path.dirname(__file__),"docs","Lire_avant.pdf")
        if os.path.exists(help_path):
            QDesktopServices.openUrl(QUrl.fromLocalFile(help_path))
        else:
            QMessageBox.warning(self.dlg, "Aide manquante",
                                "Le fichier help.pdf est introuvable dans le dossier du plugin.")

    #Timer de test
    def run_delayed(delay_ms, func):
        """Ex√©cute une fonction apr√®s un d√©lai en millisecondes."""
        QTimer.singleShot(delay_ms, func)

    def open_help(self):
        help_path = os.path.join(os.path.dirname(__file__),"docs", "help.pdf")
        if os.path.exists(help_path):
            QDesktopServices.openUrl(QUrl.fromLocalFile(help_path))
        else:
            QMessageBox.warning(self.dlg, "Aide manquante",
                                "Le fichier help.pdf est introuvable dans le dossier du plugin.")
    # M√©thode pour activer et d√©sactiver les champs

    def toggle_edit_mode(self):
        editable = self.dlg.checkEditProp.isChecked()
        # Champs de l'onglet propri√©taire
        self.dlg.nomProp.setReadOnly(not editable)
        self.dlg.lineAdress.setReadOnly(not editable)
        self.dlg.lineMail.setReadOnly(not editable)
        self.dlg.lineTel.setReadOnly(not editable)

        # Active ou d√©sactive le bouton Enregistrer
        self.dlg.btnSaveProp.setVisible(editable)

    def update_tab_visibility_checkbox(self, proprietaire):
        self.is_proprietaire = not proprietaire  # False si possession est True

        # R√©cup√®re l'√©tat de checkBoxConfig
        config_mode = self.dlg.checkBoxConfig.isChecked()

        if not proprietaire:
            # Si ce n'est pas le propri√©taire, afficher seulement "Propri√©taire"
            for i in range(self.dlg.tabWidget.count()):
                nom_onglet = self.dlg.tabWidget.tabText(i)
                self.dlg.tabWidget.setTabVisible(i, nom_onglet == 'Propri√©taire')
            self.dlg.checkBoxSaisie.setVisible(False)
        else:
            # Si c‚Äôest le propri√©taire, afficher les onglets 1 √† 4 par d√©faut
#            onglets_saisie = ['Saisie Infos', 'Saisie Tvx', 'Saisie Trait.', 'Saisie Pr√©v.']
            onglets_base = ['Informations', 'Travaux', 'Traitements', 'Pr√©visions']
            for i in range(self.dlg.tabWidget.count()):
                nom_onglet = self.dlg.tabWidget.tabText(i)
                self.dlg.tabWidget.setTabVisible(i, nom_onglet in onglets_base)
            self.dlg.checkBoxSaisie.setVisible(True)
            self.dlg.checkBoxSaisie.setChecked(False)  # Pour forcer √©tat initial

    def save_proprietaire_info(self):
        if not self.dlg.checkEditProp.isChecked():
            QMessageBox.warning(self.dlg, "√âdition d√©sactiv√©e",
                                "Veuillez cocher 'Modifier les informations' pour enregistrer les changements.")
            return

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # La couche est invalide ou incompl√®te

        if not layer:
            QMessageBox.warning(self.dlg, "Erreur", "Pas de couche s√©lectionn√©e.")
            return

        if self.current_feature_id is None:
            QMessageBox.warning(self.dlg, "Erreur", "Aucune entit√© s√©lectionn√©e.")
            return

        if not layer.isEditable():
            if not layer.startEditing():
                QMessageBox.critical(self.dlg, "Erreur", "Impossible de d√©marrer l'√©dition sur la couche.")
                return

        feature_id = self.current_feature_id
        feature = layer.getFeature(feature_id)

        # Champs √† modifier
        champ_valeurs = {
            "nom_Voisin": self.dlg.nomProp.text(),
            "adresse_Voisin": self.dlg.lineAdress.toPlainText(),
            "mail_Voisin": self.dlg.lineMail.text(),
            "tel_Voisin": self.dlg.lineTel.text(),
        }

        for nom_champ, valeur in champ_valeurs.items():
            if nom_champ in layer.fields().names():
                #print(f"‚úÖ Modification du champ {nom_champ} ‚Üí {valeur}")
                feature.setAttribute(nom_champ, valeur)
            else:
                print(f"‚ùå Champ {nom_champ} introuvable dans la couche")

        # Enregistrement
        if layer.updateFeature(feature):
            if layer.commitChanges():
                QMessageBox.information(self.dlg, "Succ√®s", "Les informations ont bien √©t√© enregistr√©es.")
                self.iface.messageBar().pushSuccess("CoordClick", "‚úÖ Modifications enregistr√©es avec succ√®s !")
            else:
                layer.rollBack()
                QMessageBox.critical(self.dlg, "Erreur", "Erreur lors de l'enregistrement des modifications.")
        else:
            QMessageBox.critical(self.dlg, "Erreur", "Impossible de mettre √† jour l'entit√©.")

            # üí° G√©rer l'affichage des onglets en fonction de 'possession' et de la case √† cocher saisie

    def toggle_saisie_tabs(self, checked):
        if self.is_proprietaire:
            onglets_saisie = ['Saisie Infos', 'Saisie Tvx', 'Saisie Trait.', 'Saisie Pr√©v.']
            onglets_base = ['Informations', 'Travaux', 'Traitements', 'Pr√©visions']
            for i in range(self.dlg.tabWidget.count()):
                nom_onglet = self.dlg.tabWidget.tabText(i)
                if checked:
                    self.dlg.tabWidget.setTabVisible(i, nom_onglet in onglets_saisie)
                else:
                    self.dlg.tabWidget.setTabVisible(i, nom_onglet in onglets_base)

    #Autorise l'√©dition des cellules de TableWidget qui alimmente les combos
    def enable_table_editing(self):
        table = self.dlg.tableWidgetData
        for row in range(table.rowCount()):
            for col in range(table.columnCount()):
                item = table.item(row, col)
                if not item:
                    item = QTableWidgetItem("")
                    table.setItem(row, col, item)
                item.setFlags(item.flags() | Qt.ItemIsEditable)

    def save_table_data(self):
        save_table_to_csv(self.dlg.tableWidgetData, self.csv_path)
        QMessageBox.information(self.dlg, "Donn√©es sauvegard√©es",
                                "Le contenu de la table a √©t√© sauvegard√© avec succ√®s.")

        # Mettre √† jour les combos apr√®s la sauvegarde
        self.refresh_combos_from_table()  # Rafra√Æchit les combos

    def update_tab_visibility(self):
        config_mode = self.dlg.checkBoxConfig.isChecked()   # Ajout de la r√©cup√©ration de config_mode ici
        saisie_mode = self.dlg.checkBoxSaisie.isChecked()

        # Cacher ou afficher checkBoxConfig selon la possession
        self.dlg.checkBoxConfig.setVisible(self.is_proprietaire)

        onglets = {
            'Informations': 0,
            'Travaux': 1,
            'Traitements': 2,
            'Pr√©visions': 3,
            'Propri√©taire': 4,
            'Saisie Infos': 5,
            'Saisie Tvx': 6,
            'Saisie Trait.': 7,
            'Saisie Pr√©v.': 8,
            'Donn√©es' : 9,
            'Analyses' : 10,
        }
        # Cacher tous les onglets par d√©faut
        for i in range(self.dlg.tabWidget.count()):
            self.dlg.tabWidget.setTabVisible(i, False)

        # üü© Si checkBoxConfig est activ√©, on affiche "Donn√©es" et Analyses
        if config_mode:
            self.dlg.tabWidget.setTabVisible(onglets['Donn√©es'], True)
            self.dlg.tabWidget.setTabVisible(onglets['Analyses'], True)
            self.enable_table_editing()   # Appel de la m√©thode autorisant l'√©dition de la table
            self.dlg.checkBoxSaisie.setVisible(False)
            # Appel l'affichage des analyses
            self.data_analyse()
            return

        # üü¶ Sinon on continue en mode normal
        self.dlg.tabWidget.setTabVisible(onglets['Donn√©es'], False)

        # Gestion des onglets en fonction de l'√©tat du propri√©taire (is_proprietaire)
        if self.is_proprietaire:
            self.dlg.checkBoxSaisie.setVisible(True)
            onglets_a_afficher = (
                ['Saisie Infos', 'Saisie Tvx', 'Saisie Trait.', 'Saisie Pr√©v.']
                if saisie_mode else
                ['Informations', 'Travaux', 'Traitements', 'Pr√©visions']
            )
        else:
            self.dlg.checkBoxSaisie.setVisible(False)
            onglets_a_afficher = ['Propri√©taire']

        for onglet in onglets_a_afficher:
            self.dlg.tabWidget.setTabVisible(onglets[onglet], True)

        QApplication.processEvents()

    def handle_checkbox_toggle(self, checked):
        self.toggle_saisie_tabs(checked)

        if not checked:
            QTimer.singleShot(100, self.refresh_all_saisie_fields)

    @staticmethod
    def qdate_from_string(value):
        """
        Convertit une cha√Æne de caract√®res (ou objet date/datetime) en QDate.
        """
        if isinstance(value, QDate):
            return value
        if isinstance(value, (datetime.date, datetime.datetime)):
            return QDate(value.year, value.month, value.day)
        if isinstance(value, str):
            try:
                year, month, day = map(int, value.split('-'))
                return QDate(year, month, day)
            except (ValueError, TypeError):
                return None
        return None

    def refresh_all_saisie_fields(self):
        """
        Recharge tous les champs (plantations, taux, combos, champs texte, etc.) depuis la couche.
        """
        # R√©cup√®re la couche et la feature s√©lectionn√©e pour les mettre √† jour en visu

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # La couche est invalide ou incompl√®te

        if layer and self.current_feature_id is not None:
            feature = layer.getFeature(self.current_feature_id)

            # Mise √† jour plantations / taux
            plantations, taux = self.build_liste_arbres(feature)
            self.dlg.plantation.setText(plantations)
            self.dlg.taux.setText(taux)

            #Mise √† jour ann√©e et total plants
            self.dlg.annee.setText(str(feature["annee"]) if feature["annee"] else "")
            self.dlg.totalPlants.setText(str(feature["totalplants"]) if feature["totalplants"] else "")

            # Mise √† jour dynamique des edit Terrain et Acces
            self.dlg.editTerrain.setText(str(feature["Terrain"]) if feature["Terrain"]else "")
            self.dlg.editAcces.setText(str(feature["Acces"]) if feature["Acces"] else "")
            self.dlg.editRemTerrain.setText(str(feature["RemTerrain"]) if feature["RemTerrain"] else "")

            # Mise √† jour du libell√© + couleur du type de parcelle
            type_parc_val = feature["typeParc"]
            if type_parc_val:
                libelle = TYPE_PARC_LIBELLES.get(type_parc_val, "Inconnu")
                self.dlg.libelleTypeParc.setText(libelle)

                layer = get_valid_active_layer(self.dlg)
                if not layer:
                    return

                couleur = get_fill_color_from_layer(layer, type_parc_val)
                if couleur:
                    self.dlg.colorFrame.setStyleSheet(f"background-color: {couleur}; border: 1px solid black;")
                else:
                    self.dlg.colorFrame.setStyleSheet("background-color: none; border: 1px solid black;")
            else:
                self.dlg.libelleTypeParc.setText("")
                self.dlg.colorFrame.setStyleSheet("background-color: none; border: 1px solid black;")

            # Mise √† jour dynamique des champs des onglets Tvx, Trait et Prev en visu
            if hasattr(self.dlg, "travauxListe"):
                texte = self.build_travaux_dates(feature)
                self.dlg.travauxListe.setPlainText(texte)

            if hasattr(self.dlg, "travauxRq"):
                texte = self.build_travaux_remarques(feature)
                self.dlg.travauxRq.setPlainText(texte)

            if hasattr(self.dlg, "traitListe"):
                texte = self.build_trait_dates(feature)
                self.dlg.traitListe.setPlainText(texte)

            if hasattr(self.dlg, "traitRq"):
                texte = self.build_trait_remarques(feature)
                self.dlg.traitRq.setPlainText(texte)

            if hasattr(self.dlg, "prevListe"):
                texte = self.build_prev_dates(feature)
                self.dlg.prevListe.setPlainText(texte)

            if hasattr(self.dlg, "prevRq"):
                texte = self.build_prev_remarques(feature)
                self.dlg.prevRq.setPlainText(texte)

            # Mise √† jour des combos
            for prefix, combo_base in [("plant", "comboPlant"), ("Tvx", "comboTvx"),
                                       ("Trait", "comboTrait"), ("Prev", "comboPrev")]:
                self.init_saisie_combos(prefix, combo_base, feature)


    def handle_possession_toggle(self, state):
        self.is_proprietaire = bool(state)
        self.enregistrer_possession(state)
        self.update_tab_visibility()

    def enregistrer_possession(self, state):
        """Met √† jour le champ Possession selon la case √† cocher"""

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # Couche invalide ou non compatible

        if not layer.isEditable():
            layer.startEditing()

        feature = layer.getFeature(self.current_feature_id)
        if feature:
            feature['Possession'] = state  # True ou False
            layer.updateFeature(feature)

    # Raffraichissement des combos par rapport √† tablewidgetdata
    def refresh_combos_from_table(self):
        self.populate_saisie_combos("Tvx", "comboTvx", 1)
        self.populate_saisie_combos("Trait", "comboTrait", 2)
        self.populate_saisie_combos("Prev", "comboPrev", 1)
        self.populate_saisie_combos("Plant", "comboPlant", 0)
    #    self.populate_terrain_acces_combos()

    def populate_saisie_combos(self, prefix, combo_base_name, column_index):
        """
        Remplit les comboBox d‚Äôun onglet Saisie (Tvx, Trait, Prev).

        Args:
            prefix (str): pr√©fixe du champ attributaire, ex: 'Tvx', 'Trait', 'Prev'
            combo_base_name (str): nom de base des combo ex: 'comboTvx', 'comtrait', 'comboPrev'
            column_index (int): index de colonne dans tableWidgetData (0-based)
        """
        # R√©cup√©rer les valeurs uniques de la colonne
        raw_data = extract_table_values(self.dlg.tableWidgetData, [column_index])
        valeurs = unique_values_per_column(raw_data)[0]

        nb_combos = SAISIE_COMBO_COUNTS.get(prefix, 6)  # d√©faut = 6 si inconnu

        for i in range(1, nb_combos + 1):
            combo = getattr(self.dlg, f"{combo_base_name}{i}", None)
            if combo is not None:
                combo.clear()
                combo.addItem("")
                combo.addItems(valeurs)

    def remplir_combobox_terrain_acces(self, valeur_terrain_actuelle='', valeur_acces_actuelle=''):
        """Remplit les comboModifTerrain et comboModifAcces avec les valeurs uniques de tableWidgetData.
        S√©lectionne la valeur correspondante si elle existe.
        """

        table = self.dlg.tableWidgetData

        # Utiliser des ensembles pour √©viter les doublons
        valeurs_terrain = set()
        valeurs_acces = set()


        for row in range(table.rowCount()):
            item_terrain = table.item(row, 4)  # Colonne Terrain
            if item_terrain:
                valeur = item_terrain.text().strip()
                if valeur:
                    valeurs_terrain.add(valeur)

            item_acces = table.item(row, 3)  # Colonne Acces
            if item_acces:
                valeur = item_acces.text().strip()
                if valeur:
                    valeurs_acces.add(valeur)

        # üîç AJOUT ICI : lecture directe de la couche active (table attributaire QGIS)
        #layer = get_valid_active_layer(self.dlg)
        # if layer:
        #     for feature in layer.getFeatures():
        #         terrain = feature['Terrain'] if 'Terrain' in feature.fields().names() else None
        #         acces = feature['Acces'] if 'Acces' in feature.fields().names() else None

        # Remplit les combobox avec donn√©es tableWidgetData
        self.dlg.comboModifTerrain.clear()
        self.dlg.comboModifTerrain.addItem("")
        self.dlg.comboModifTerrain.addItems(sorted(valeurs_terrain))

        self.dlg.comboModifAcces.clear()
        self.dlg.comboModifAcces.addItem("")
        self.dlg.comboModifAcces.addItems(sorted(valeurs_acces))

        # S√©lectionne les valeurs existantes si fournies
        if valeur_terrain_actuelle:
            index_terrain = self.dlg.comboModifTerrain.findText(valeur_terrain_actuelle)
            if index_terrain != -1:
                self.dlg.comboModifTerrain.setCurrentIndex(index_terrain)

        if valeur_acces_actuelle:
            index_acces = self.dlg.comboModifAcces.findText(valeur_acces_actuelle)
            if index_acces != -1:
                self.dlg.comboModifAcces.setCurrentIndex(index_acces)


    def init_combo_modif_legend(self, feature):
        # R√©cup√®re l'entier depuis la table attributaire
        type_parc_val = feature['typeParc']

        # Convertit en libell√© via le dictionnaire
        libelle = TYPE_PARC_LIBELLES.get(type_parc_val, "")


        # Recherche le libell√© dans la combo
        index = self.dlg.comboModifLegend.findText(libelle, Qt.MatchFixedString)

        if index >= 0:
            self.dlg.comboModifLegend.setCurrentIndex(index)

        else:
            self.dlg.comboModifLegend.setCurrentIndex(0)


    def init_saisie_combos(self, prefix, combo_base_name, feature):
        """
        Initialise les combos avec les valeurs de l'entit√© (feature).

        Args:
            prefix (str): pr√©fixe des champs ('Tvx', 'Trait', 'Previ')
            combo_base_name (str): nom de base des combo ex: 'comboTvx', 'comtrait', 'comboPrev'
        """
        nb_combos = SAISIE_COMBO_COUNTS.get(prefix, 6)  # üî• Ici on r√©cup√®re combien de combos utiliser

        for i in range(1, nb_combos + 1):
            field_name = f"{prefix}{i}"
            combo_name = f"{combo_base_name}{i}"
            combo = getattr(self.dlg, combo_name, None)
            if combo is not None:
                # ‚û°Ô∏è V√©rifie si le champ existe
                if field_name not in feature.fields().names():
                    val = ""  # Champ manquant => vide
                else:
                    val = feature[field_name] or ""
                index = combo.findText(val)

                if index >= 0:
                    combo.setCurrentIndex(index)
                else:
                    combo.setCurrentIndex(0)  # Option par d√©faut si valeur absente

    def on_saisie_combo_changed(self, prefix, combo_base_name, i):
        """
        G√®re la mise √† jour du champ {prefix}{i} lorsque le combo change.
        Commit, relance l'√©dition, et rafra√Æchit l'affichage des combos.
        """
        combo = getattr(self.dlg, f"{combo_base_name}{i}")
        new_val = combo.currentText()

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # La couche est invalide ou incompl√®te

        fid = self.current_feature_id

        if layer is None or fid is None:
            return

        # 1. D√©marrer l'√©dition si besoin
        if not layer.isEditable():
            if not layer.startEditing():
                QMessageBox.critical(self.dlg, "Erreur",
                                     "Impossible de d√©marrer l'√©dition sur la couche.")
                return

        # 2. Modifier l'attribut
        field_idx = layer.fields().indexOf(f"{prefix}{i}")
        if field_idx < 0:
            QMessageBox.critical(self.dlg, "Erreur",
                                 f"Le champ {prefix}{i} est introuvable.")
            return

        if not layer.changeAttributeValue(fid, field_idx, new_val):
            layer.rollBack()
            QMessageBox.critical(self.dlg, "Erreur",
                                 "√âchec de la modification de l'attribut.")
            return

        # 3. Commit et relancer l'√©dition
        if not layer.commitChanges():
            QMessageBox.critical(self.dlg, "Erreur",
                                 "√âchec de l'enregistrement des modifications commbo changed.")
            layer.rollBack()
            return
        else:
            layer.startEditing()
            self.iface.messageBar().pushMessage("Succ√®s",
                                                f"{prefix}{i} mis √† jour ‚Üí {new_val}", level=0)

        # 4. Rafra√Æchir l'affichage des combos - A v√©rifier, semble inutile
        feature = layer.getFeature(fid)
        self.init_saisie_combos(prefix, combo_base_name, feature)


    def enregistrer_modifs_saisie(self, prefix, combo_prefix, date_prefix=None, rem_prefix=None):
        """
        Enregistre les modifications pour un onglet de saisie donn√© (Tvx, Trait, Prev, Infos...).

        :param prefix: Pr√©fixe des champs dans la couche (ex: 'Tvx', 'Trait', 'Prev', 'plant')
        :param combo_prefix: Pr√©fixe des combobox dans l‚ÄôUI (ex: 'comboTvx', 'comboTrait')
        :param date_prefix: (Optionnel) Pr√©fixe des widgets de date dans l‚ÄôUI (ex: 'dateTvx')
        :param rem_prefix: (Optionnel) Pr√©fixe des widgets de remarque dans l‚ÄôUI (ex: 'remTvx')
        """
        # üîç R√©cup√©ration de la couche

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # La couche est invalide ou incompl√®te

        if not layer:
            show_error_bar(self.iface, "Erreur", "Aucune couche s√©lectionn√©e.")
            return

        # üîí V√©rifie l'entit√© s√©lectionn√©e
        if self.current_feature_id is None:
            log_warning("Aucune entit√© s√©lectionn√©e.")
            return

        # üîß Passe la couche en mode √©dition si n√©cessaire
        if not layer.isEditable() and not layer.startEditing():
            show_error_bar(self.iface, "Erreur", "Impossible de passer la couche en mode √©dition.")
            return

        # üîÑ R√©cup√©ration de l'entit√© courante
        feature = layer.getFeature(self.current_feature_id)

        # ‚úÖ Sauvegarde des valeurs des combobox (obligatoire)
        self.save_saisie_values(layer, feature, prefix, combo_prefix)

        # üóìÔ∏èüí¨ Si des champs date/remarque sont d√©finis, on les enregistre aussi
        if date_prefix and rem_prefix:
            self.save_saisie_fields(prefix, date_prefix, rem_prefix)

        # üíæ Validation des modifications
        if layer.commitChanges():
            current_tab_name = self.dlg.tabWidget.tabText(self.dlg.tabWidget.currentIndex())
            show_success_bar(self.iface, "‚úÖ CoordClick", f"Modifications enregistr√©es pour : {current_tab_name}")
            layer.startEditing()  # Repassage en mode √©dition pour d'autres modifs
        else:
            layer.rollBack()
            show_error_bar(self.iface, "‚ùå Erreur", "√âchec de l'enregistrement des modifications Saisie.")

    def save_saisie_values(self, layer, feature, prefix, combo_base):
        """
        Sauvegarde les valeurs des combobox de saisie dans les champs correspondants.
        """
        updates = {}

        nb_combos = SAISIE_COMBO_COUNTS.get(prefix, 6)  # üî• Ajout√© ici aussi !

        for i in range(1, nb_combos + 1):
            combo_name = f"{combo_base}{i}"
            combo = getattr(self.dlg, combo_name, None)
            field_name = f"{prefix}{i}"

            if combo is None or not field_name:
                continue

            if field_name not in feature.fields().names():
                log_warning(f"Champ {field_name} absent de la couche.")
                continue

            new_value = combo.currentText()
            if feature[field_name] != new_value:
                updates[layer.fields().indexFromName(field_name)] = new_value

        if updates:
            res = layer.changeAttributeValues(feature.id(), updates)
            if res:
                log_debug(f"‚úÖ Valeurs mises √† jour pour {prefix}: {updates}")
            else:
                log_error("‚ùå √âchec lors de l'application des modifications.")
        else:
            log_debug("‚ÑπÔ∏è Aucune modification d√©tect√©e.")

    def connect_enregistrement_boutons(self):
        """
        Connecte automatiquement tous les boutons d'enregistrement li√©s aux combos de saisie.
        """
        saisie_combo_buttons = {
            "btnEnregTvx": ("Tvx", "comboTvx", "dateTvx", "remTvx"),
            "btnEnregTrait": ("Trait", "comboTrait", "dateTrait", "remTrait"),
            "btnEnregPrev": ("Prev", "comboPrev", "datePrev", "remPrev"),
            "btnEnregInfos": (
                "plant",
                "comboPlant",
            ),  # üÜï Saisie Informations
        }

        # Connexion des boutons standards
        for bouton_name, params in saisie_combo_buttons.items():
            bouton = getattr(self.dlg, bouton_name, None)
            if bouton:
                bouton.clicked.connect(lambda _, p=params: self.enregistrer_modifs_saisie(*p))

        # Connexion sp√©cifique pour Saisie Infos
        bouton_infos = getattr(self.dlg, "btnEnregInfos", None)
        if bouton_infos:
            bouton_infos.clicked.connect(self.save_infos_saisie)  # üëà Appel direct √† la m√©thode sp√©cifique

    def connect_saisie_combos(self):
        erreurs = []  # Liste pour stocker les erreurs

        for prefix, base_name in [("plant", "comboPlant"),("Tvx", "comboTvx"), ("Trait", "comboTrait"), ("Prev", "comboPrev")]:
            nb_combos = SAISIE_COMBO_COUNTS.get(prefix, 6)
            for i in range(1, nb_combos + 1):
                combo = getattr(self.dlg, f"{base_name}{i}", None)
                if combo is not None:
                    combo.currentIndexChanged.connect(
                        lambda _, i=i, p=prefix, b=base_name: self.on_saisie_combo_changed(p, b, i)
                    )
                else:
                    erreurs.append(f"{base_name}{i}")

        if erreurs:
            QMessageBox.critical(self.dlg, "Erreur", f"Les combobox suivantes sont introuvables : {', '.join(erreurs)}")



    def update_saisie_fields(self, feature, prefix, combo_prefix):
        """
        Met √† jour dynamiquement les combobox de saisie (Tvx, Traitement, Pr√©vision)
        en fonction des donn√©es du feature s√©lectionn√©.

        :param feature: l'entit√© s√©lectionn√©e
        :param prefix: pr√©fixe du champ (ex: 'Tvx', 'Trait', 'Prev')
        :param combo_prefix: pr√©fixe des objets combobox (ex: 'comboTvx', 'comboTrait', 'comboPrev')
        """
        nb_combos = SAISIE_COMBO_COUNTS.get(prefix, 6)
        for i in range(1, nb_combos + 1):
            field_name = f"{prefix}{i}"
            combo_name = f"{combo_prefix}{i}"

            value = feature[field_name] if field_name in feature.fields().names() else None
            combo = getattr(self.dlg, combo_name, None)

            if combo:
                if value:
                    combo.setCurrentText(str(value))
                else:
                    combo.setCurrentIndex(-1)  # Aucun √©l√©ment s√©lectionn√©

    def on_feature_selected(self, feature):
        for name in feature.fields().names():
            # Onglet 6
            self.update_saisie_combo_fields(feature, "Tvx", "comboTvx")
            self.update_saisie_extra_fields(feature, "Tvx", "dateTvx", "remTvx", date_type="QDateEdit")
            # Onglet 7
            self.update_saisie_combo_fields(feature, "Trait", "comboTrait")
            self.update_saisie_extra_fields(feature, "Trait", "dateTrait", "remTrait", date_type="QDateEdit")
            #Onglet 8
            self.update_saisie_combo_fields(feature, "Prev", "comboPrev")
            self.update_saisie_extra_fields(feature, "Prev", "datePrev", "remPrev", date_type="QLineEdit")


    def on_feature_selection_changed(self):
        layer = self.iface.activeLayer()
        selected = layer.selectedFeatures()
        if selected:
            feature = selected[0]
            self.on_feature_selected(feature)

    def update_saisie_extra_fields(self, feature, prefix, date_prefix, rem_prefix, date_type="QDateEdit",
                                   rem_type="QTextEdit"):
        """
        Met √† jour les champs de date et de remarque associ√©s aux combobox,
        en fonction du prefix (Tvx, Trait, Prev), en utilisant SAISIE_COMBO_COUNTS.
        """
        nb_champs = SAISIE_COMBO_COUNTS.get(prefix, 6)

        for i in range(1, nb_champs + 1):
            # --- DATE ---
            date_field_name = f"date{prefix}{i}"
            date_widget = getattr(self.dlg, f"{date_prefix}{i}", None)
            if date_widget and date_field_name in feature.fields().names():
                value = feature[date_field_name]
                if value:
                    if date_type == "QDateEdit":
                        date = QDate.fromString(value, "yyyy-MM-dd")
                        date_widget.setDate(date)
                    else:
                        date_widget.setText(str(value))
                else:
                    date_widget.clear()

            # --- REMARQUE ---
            rem_field_name = f"rem{prefix}{i}"
            rem_widget = getattr(self.dlg, f"{rem_prefix}{i}", None)
            if rem_widget and rem_field_name in feature.fields().names():
                value = feature[rem_field_name]
                if value:
                    rem_widget.setText(str(value))
                else:
                    rem_widget.clear()

    def update_saisie_combo_fields(self, feature, prefix, combo_base):
        """
        Met √† jour les combobox pour un groupe donn√© (ex : Tvx, Trait, Prev) directement depuis l'entit√©.
        """
        nb_combos = SAISIE_COMBO_COUNTS.get(prefix, 6)
        for i in range(1, nb_combos + 1):
            field_name = f"{prefix}{i}"
            combo_name = f"{combo_base}{i}"
            combo = getattr(self.dlg, combo_name, None)
            if combo:
                value = feature[field_name]


                # üëâ Remettre les options standards (depuis ta table ou liste pr√©d√©finie)
                self.populate_saisie_combo(combo, prefix)

                if value:
                    # Cherche la valeur dans les options
                    index = combo.findText(value)
                    if index != -1:
                        combo.setCurrentIndex(index)
                    else:
                        # Pas trouv√©e ? Ajoute-la et s√©lectionne
                        combo.addItem(value)
                        combo.setCurrentIndex(combo.count() - 1)
                else:
                    combo.setCurrentIndex(0)

    def populate_saisie_combo(self, combo, prefix):
        """
        Remplit une comboBox sp√©cifique avec les valeurs possibles pour le prefix donn√©.
        """
        # Mapping des pr√©fixes √† leur colonne
        column_mapping = {
            "Tvx": 1,
            "Trait": 2,
            "Prev": 2,  # Prev utilise la m√™me colonne que Trait
        }

        column_index = column_mapping.get(prefix)

        if column_index is None:
            log_warning(f"Pr√©fixe inconnu pour populate_saisie_combo : {prefix}")
            return

        raw_data = extract_table_values(self.dlg.tableWidgetData, [column_index])
        valeurs = unique_values_per_column(raw_data)[0]

        combo.clear()
        combo.addItem("")  # Valeur vide en premier
        combo.addItems(valeurs)

        QTimer.singleShot(100, self.populate_saisie_combo)

    @staticmethod
    def build_liste_arbres(feature):
        """
        R√©cup√®re les champs plant1..plant4 et Tx1..Tx4 de feature
        et renvoie deux cha√Ænes √† afficher dans plantation et taux.
        """
        fields_plants = ['plant1', 'plant2', 'plant3', 'plant4']
        fields_tx = ['Tx1', 'Tx2', 'Tx3', 'Tx4']

        valeurs_plants = [str(feature[f]) for f in fields_plants if feature[f]]
        valeurs_tx = [str(feature[f]) for f in fields_tx if feature[f]]

        to_str_plants = "\n".join(valeurs_plants) if valeurs_plants else "Aucune essence d√©finie ici..."
        to_str_tx = "\n".join(valeurs_tx) if valeurs_tx else "Aucun"

        return to_str_plants, to_str_tx

    @staticmethod
    def build_travaux_dates(feature):
        mon_tab = []

        for i in range(1, SAISIE_COMBO_COUNTS["Tvx"] + 1):  # cr√©ation liste des dates et remarques
            dat = f"dateTvx{i}"
            rq = f"Tvx{i}"
            mon_tab.append([dat, rq])

        fields = sum(mon_tab, [])
        str2 = '\n'.join(
            f'{format_date(feature[a])} : {feature[b]}'
            for a, b in batched(fields, 2) if feature[b]
        )
        if not str2:
            return 'Aucun travaux effectu√©s ici...'
        return str2

    @staticmethod
    def build_travaux_remarques(feature):

        mon_tab = []

        for i in range(1, SAISIE_COMBO_COUNTS["Tvx"] + 1):           #cr√©ation liste des dates et remarques du display_point
            dat = "dateTvx" + str(i)
            rq = "remTvx" + str(i)
            mon_tab.append([dat, rq])

        fields = sum(mon_tab,[])
        str3 = '\n'.join(
            f'{format_date(feature[a])} : {feature[b]}'
            for a, b in batched(fields, 2) if feature[b]
        )
        return str3 if str3 else "..."

    @staticmethod
    def build_trait_dates(feature):

        mon_tab = []

        for i in range(1, SAISIE_COMBO_COUNTS["Trait"] + 1):  # cr√©ation liste des dates et remarques du display_point
            dat = "dateTrait" + str(i)
            rq = "Trait" + str(i)
            mon_tab.append([dat, rq])

        fields = sum(mon_tab, [])
        str4 =  '\n'.join(
            f'{format_date(feature[a])} : {feature[b]}'
            for a, b in batched(fields, 2) if feature[b]
        )  # contr√¥le pr√©sence champ remarque si date existe et concatenation champ date et travaux
        if not str4:
            return 'Aucun traitement effectu√©s ici...'
        return str4

    @staticmethod
    def build_trait_remarques(feature):

        mon_tab = []

        for i in range(1, SAISIE_COMBO_COUNTS["Trait"] + 1):  # cr√©ation liste des dates et remarques du display_point
            dat = "dateTrait" + str(i)
            rq = "remTrait" + str(i)
            mon_tab.append([dat, rq])

        fields = sum(mon_tab, [])
        str5 = '\n'.join(
            f'{format_date(feature[a])} : {feature[b]}'
            for a, b in batched(fields, 2) if feature[b]
        )  # contr√¥le pr√©sence champ remarque si date existe
        return str5 if str5 else "..."  # si aucune remarque des traitements dans la parcelle

    @staticmethod
    def build_prev_dates(feature):

        mon_tab = []

        for i in range(1, SAISIE_COMBO_COUNTS["Prev"] + 1):
            dat = "datePrev" + str(i)
            rq = "Prev" + str(i)
            mon_tab.append([dat, rq])

        fields = sum(mon_tab, [])
        str6 =  '\n'.join(
            f'{feature[a]} : {feature[b]}'
            for a, b in batched(fields, 2) if feature[b]
        )  # contr√¥le pr√©sence champ remarque si date existe et concatenation champ date et pr√©visions
        if not str6:
            return 'Aucun travaux pr√©vus ici...'
        return str6

    # Affichage de la liste des remarques et controle des champs nuls

    @staticmethod
    def build_prev_remarques(feature):

        mon_tab = []

        for i in range(1, SAISIE_COMBO_COUNTS["Prev"] + 1):  # cr√©ation liste des dates et remarques du display_point
            dat = "datePrev" + str(i)
            rq = "remPrev" + str(i)
            mon_tab.append([dat, rq])

        fields = sum(mon_tab, [])
        str7 = '\n'.join(
            f'{feature[a]} : {feature[b]}'
            for a, b in batched(fields, 2) if feature[b]
        )  # contr√¥le pr√©sence champ remarque si date existe
        return str7 if str7 else "..."  # si aucune remarque sur les pr√©visions dans la parcelle

    #Gestion du combobox ModifLegend pour le remplir avec la liste
    def remplir_combo_modif_legend(self):
        self.dlg.comboModifLegend.clear()

        # On remplit la combo avec les libell√©s en gardant les cl√©s associ√©es
        for key in sorted(TYPE_PARC_LIBELLES.keys()):
            label = TYPE_PARC_LIBELLES[key]
            self.dlg.comboModifLegend.addItem(label, key)

    def save_type_parc_value(self, layer, feature):
        """
        Sauvegarde la valeur de typeParc (entier) en fonction du libell√© s√©lectionn√© dans comboModifLegend.
        """
        libelle_selectionne = self.dlg.comboModifLegend.currentText()

        # Recherche l'entier correspondant dans le dictionnaire inverse
        inverse_dict = {v: k for k, v in TYPE_PARC_LIBELLES.items()}
        type_parc_val = inverse_dict.get(libelle_selectionne, None)

        if type_parc_val is None:
            log_warning(f"‚ö†Ô∏è Libell√© '{libelle_selectionne}' non trouv√© dans le dictionnaire.")
            return

        if 'typeParc' not in feature.fields().names():
            log_error("‚ùå Champ 'typeParc' non trouv√© dans la couche.")
            return

        if feature['typeParc'] != type_parc_val:
            index = layer.fields().indexFromName('typeParc')
            res = layer.changeAttributeValues(feature.id(), {index: type_parc_val})
            if res:
                log_debug(f"‚úÖ Champ 'typeParc' mis √† jour avec la valeur {type_parc_val}")
            else:
                log_error("‚ùå √âchec de mise √† jour pour 'typeParc'")
        else:
            log_debug("‚ÑπÔ∏è Aucun changement d√©tect√© pour 'typeParc'")

    def remplir_champs_modifiables(self, feature):
        """Remplit tous les champs modifiables √† partir d'une entit√©, de fa√ßon g√©n√©rique."""
        self.dlg.anneeModif.setText(safe_str(feature['annee']))
        self.dlg.totalPlantsModif.setText(safe_str(feature['totalplants']))
        self.dlg.remModifTerrain.setPlainText(safe_str(feature['RemTerrain']))
        # Dictionnaire des pr√©fixes : nom champ QGIS -> pr√©fixe widget Qt
        champs = {
            'Tx': 'txModif',
            'remTvx': 'remTvx',
            'remTrait': 'remTrait',
            'remPrev': 'remPrev',
            'datePrev': 'datePrev'
        }

        for prefix, widget_prefix in champs.items():
            count = SAISIE_COMBO_COUNTS.get(prefix.replace("rem", ""), 6)  # remTvx -> Tvx
            for i in range(1, count + 1):
                champ_nom = f"{prefix}{i}"
                widget_nom = f"{widget_prefix}{i}"
                widget = getattr(self.dlg, widget_nom, None)
                if widget and champ_nom in feature.fields().names():
                    widget.setText(safe_str(feature[champ_nom]))
            # Gestion des dates (dateTvx, dateTrait, datePrev)
            date_champs = {
                'dateTvx': 'dateTvx',
                'dateTrait': 'dateTrait',
            }

            for prefix, widget_prefix in date_champs.items():
                count = SAISIE_COMBO_COUNTS.get(prefix.replace("date", ""), 6)  # dateTvx -> Tvx
                for i in range(1, count + 1):
                    champ_nom = f"{prefix}{i}"
                    widget_nom = f"{widget_prefix}{i}"
                    widget = getattr(self.dlg, widget_nom, None)
                    if widget and champ_nom in feature.fields().names():
                        value = feature[champ_nom]
                        if value:
                            if isinstance(value, str):
                                # Pour les cha√Ænes de caract√®res, directement les mettre
                                widget.setText(safe_str(value))
                            elif isinstance(value, QDate):
                                # Pour les dates, mettre sous format QDate
                                widget.setDate(value)

    def save_saisie_fields(self, prefix, date_prefix, rem_prefix):
        """
        Sauvegarde les champs de l'onglet g√©n√©rique (Tvx, Trait, Prev).
        :param prefix: Le pr√©fixe des champs de l'entit√© (ex : 'Tvx', 'Trait', 'Prev')
        :param date_prefix: Le pr√©fixe des widgets de date (ex : 'dateTvx', 'dateTrait', 'datePrev')
        :param rem_prefix: Le pr√©fixe des widgets de remarque (ex : 'remTvx', 'remTrait', 'remPrev')
        """

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # La couche est invalide ou incompl√®te

        if not layer:
            QMessageBox.warning(self.dlg, "Erreur", "Aucune couche s√©lectionn√©e.")
            return

        if self.current_feature_id is None:
            QMessageBox.warning(self.dlg, "Erreur", "Aucune entit√© s√©lectionn√©e.")
            return

        if not layer.isEditable():
            if not layer.startEditing():
                QMessageBox.critical(self.dlg, "Erreur", "Impossible de d√©marrer l'√©dition sur la couche.")
                return

        feature = layer.getFeature(self.current_feature_id)
        nb_champs = SAISIE_COMBO_COUNTS.get(prefix, 6)

        for i in range(1, nb_champs + 1):
            date_field = f"date{prefix}{i}"
            rem_field = f"rem{prefix}{i}"

            # --- DATE ---
            date_widget = getattr(self.dlg, f"{date_prefix}{i}", None)
            if date_widget and date_field in feature.fields().names():
                if hasattr(date_widget, 'date'):  # QDateEdit
                    value = date_widget.date().toString("yyyy-MM-dd")
                else:  # QLineEdit
                    value = date_widget.text()
                feature.setAttribute(date_field, value)
            else:
                print(f"‚ö†Ô∏è Champ ou widget date manquant : {date_field}")

            # --- REMARQUE ---
            rem_widget = getattr(self.dlg, f"{rem_prefix}{i}", None)
            if rem_widget and rem_field in feature.fields().names():
                if hasattr(rem_widget, 'toPlainText'):  # QTextEdit
                    value = rem_widget.toPlainText()
                else:  # QLineEdit
                    value = rem_widget.text()
                feature.setAttribute(rem_field, value)
            else:
                print(f"‚ö†Ô∏è Champ ou widget remarque manquant : {rem_field}")

        # Mise √† jour de l'entit√© dans la couche (pas de commit ici)
        if not layer.updateFeature(feature):
            QMessageBox.critical(self.dlg, "Erreur", "√âchec de la mise √† jour de l'entit√©.")
            return


    def connect_save_buttons(self):
        """Connecte les boutons de sauvegarde aux m√©thodes de sauvegarde pour chaque onglet."""
        self.dlg.btnEnregTvx.clicked.connect(lambda: self.save_saisie_fields('Tvx', 'dateTx', 'remTx'))
        self.dlg.btnEnregTrait.clicked.connect(lambda: self.save_saisie_fields('Trait', 'dateTrait', 'remTrait'))
        self.dlg.btnEnregPrev.clicked.connect(lambda: self.save_saisie_fields('Prev', 'datePrev', 'remPrev'))

        # Connexion pour le bouton de l'onglet Saisie Infos, en ajoutant Tx1 √† 4, annee, totalplants

    def save_infos_saisie(self):
        """Sauvegarde les informations modifi√©es dans l'onglet Saisie Infos."""

        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return  # La couche est invalide ou incompl√®te

        if not layer:
            QMessageBox.warning(self.dlg, "Erreur", "Aucune couche s√©lectionn√©e.")
            return

        if self.current_feature_id is None:
            QMessageBox.warning(self.dlg, "Erreur", "Aucune entit√© s√©lectionn√©e.")
            return

        if not layer.isEditable():
            if not layer.startEditing():
                QMessageBox.critical(self.dlg, "Erreur", "Impossible de d√©marrer l'√©dition sur la couche.")
                return

        feature_id = self.current_feature_id
        feature = layer.getFeature(feature_id)

        # ‚úÖ V√©rifie que la somme des taux ne d√©passe pas 100
        tx_fields = [self.dlg.txModif1, self.dlg.txModif2, self.dlg.txModif3, self.dlg.txModif4]
        tx_values = []

        for tx in tx_fields:
            val = tx.text().strip()
            if val and val.upper() != "NULL":
                try:
                    tx_values.append(int(val))
                except ValueError:
                    QMessageBox.warning(self.dlg, "Erreur",
                                        f"Valeur invalide dans un des taux : '{val}' (entier attendu)")
                    return

        total_tx = sum(tx_values)

        if total_tx > 100:
            QMessageBox.warning(self.dlg, "Erreur",
                                f"La somme des taux ne peut pas d√©passer 100% (actuellement : {total_tx}%)")
            return

        # Champs √† modifier dans l'onglet Saisie Infos
        champ_valeurs = {
            "annee": self.dlg.anneeModif.text(),
            "totalplants": self.dlg.totalPlantsModif.text(),
            "Tx1": self.dlg.txModif1.text(),
            "Tx2": self.dlg.txModif2.text(),
            "Tx3": self.dlg.txModif3.text(),
            "Tx4": self.dlg.txModif4.text(),
            "Terrain": self.dlg.comboModifTerrain.currentText(),
            "Acces": self.dlg.comboModifAcces.currentText(),
            "RemTerrain": self.dlg.remModifTerrain.toPlainText(),
            # Ajouter ici d'autres champs si n√©cessaire
            # "autre_champ": self.dlg.nomQtWidget.text(),
        }

        for nom_champ, valeur in champ_valeurs.items():
            if nom_champ in layer.fields().names():
                champ_type = layer.fields().field(nom_champ).type()
                # V√©rification propre des "valeurs vides"
                if valeur.strip().upper() in ("", "NULL", "NONE"):
                    feature.setAttribute(nom_champ, None)
                elif champ_type in (QVariant.Int, QVariant.LongLong):
                    feature.setAttribute(nom_champ, int(valeur))
                elif champ_type == QVariant.Double:
                    feature.setAttribute(nom_champ, float(valeur))
                else:
                    feature.setAttribute(nom_champ, valeur)
            else:
                print(f"‚ùå Champ {nom_champ} introuvable dans la couche")

        # ‚ûï Sauvegarde du champ typeParc (depuis comboModifLegend)
        libelle = self.dlg.comboModifLegend.currentText()
        inverse_dict = {v: k for k, v in TYPE_PARC_LIBELLES.items()}
        type_parc_val = inverse_dict.get(libelle, None)

        if type_parc_val is None:
            QMessageBox.warning(self.dlg, "Erreur", f"Le libell√© '{libelle}' n'est pas reconnu.")
            return

        if 'typeParc' not in layer.fields().names():
            QMessageBox.critical(self.dlg, "Erreur", "Le champ 'typeParc' est introuvable dans la couche.")
            return

        feature.setAttribute('typeParc', type_parc_val)


        # Appliquer les modifications
        if not layer.updateFeature(feature):
            QMessageBox.critical(self.dlg, "Erreur", "√âchec de la mise √† jour de l'entit√©.")
            return

        if not layer.commitChanges():
            QMessageBox.critical(self.dlg, "Erreur", "√âchec lors de la sauvegarde des modifications.")
            return
        # üî• Repasser en mode √©dition
        if not layer.startEditing():
            QMessageBox.critical(self.dlg, "Erreur", "Impossible de repasser en mode √©dition apr√®s sauvegarde.")

        QMessageBox.information(self.dlg, "Succ√®s", "Les informations ont √©t√© enregistr√©es avec succ√®s.")

    def afficher_labels_dynamiques_sur_couche(self):
        """Affiche dynamiquement les √©tiquettes selon 'Possession' et 'typeParc'."""
        layer = self.iface.activeLayer()
        if not isinstance(layer, QgsVectorLayer):
            print("Pas de couche vecteur active.")
            return

        root_rule = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())

        label_expression = (
            '"section" || "numero" || '
            'CASE WHEN "indice_parc" IS NOT NULL AND "indice_parc" != \'\' '
            'THEN \'\' || "indice_parc" ELSE \'\' END || '
            '\'\\n\' || "SURFACE" || \' ares\''
        )

        # R√®gle 1 : Possession = TRUE (et on applique une couleur selon typeParc)
        rule1 = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
        rule1.setFilterExpression('"Possession" = TRUE AND "typePArc" NOT IN (6,7)')

        settings1 = QgsPalLayerSettings()
        settings1.isExpression = True
        settings1.fieldName = label_expression

        format1 = QgsTextFormat()
        format1.setFont(QFont("Arial", 9))
        format1.setSize(10)
        format1.setColor(QColor("black"))  # Valeur par d√©faut, on peut en ajouter d'autres

        settings1.setFormat(format1)
        rule1.setSettings(settings1)
        rule1.setDescription("Parcelles possession = True")
        root_rule.appendChild(rule1)

        # R√®gle 2 : Possession = FALSE
        rule2 = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
        rule2.setFilterExpression('"Possession" = FALSE OR "Possession" IS NULL')

        settings2 = QgsPalLayerSettings()
        settings2.isExpression = True
        settings2.fieldName = '"section" || "numero"'

        format2 = QgsTextFormat()
        format2.setFont(QFont("Arial", 9))
        format2.setSize(9)
        format2.setColor(QColor("black"))  # Par exemple rouge

     #   format2.setBuffer(buffer_settings)
        settings2.setFormat(format2)
        rule2.setSettings(settings2)
        rule2.setDescription("Liste g√©n√©rale parrcelles")
        root_rule.appendChild(rule2)


    #     # R√®gle 3 : toutes les parcelles dont le propri√©taire est connus sont en violet
        rule3 = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
        rule3.setFilterExpression('("Possession" = FALSE OR "Possession" IS NULL) AND "nom_Voisin" IS NOT NULL')

        settings3 = QgsPalLayerSettings()
        settings3.isExpression = True
        settings3.fieldName = '"section" || "numero"'

        format3 = QgsTextFormat()
        format3.setFont(QFont("Arial", 9))
        format3.setSize(9)
        format3.setColor(QColor("#7f00ff"))  # Valeur par d√©faut, on peut en ajouter d'autres

        settings3.setFormat(format3)
        rule3.setSettings(settings3)
        rule3.setDescription("Parcelles propri√©taires connus")
        root_rule.appendChild(rule3)

        # # R√®gle 4 : Possession = TRUE (et on applique une couleur selon typeParc)
        rule4 = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
        rule4.setFilterExpression('"Possession" = TRUE AND "typePArc" IN(6,7)')

        settings4 = QgsPalLayerSettings()
        settings4.isExpression = True
        settings4.fieldName = '"section" || "numero" || \'\\n\' || "SURFACE" || \' ares\''

        # Cr√©ation de la police avec style gras
        font = QFont("Arial", 10)
        font.setBold(True)  # Active le gras

        format4 = QgsTextFormat()
        format4.setFont(font)
        format4.setSize(10)
        format4.setColor(QColor("white"))  # Valeur par d√©faut, on peut en ajouter d'autres

        settings4.setFormat(format4)
        rule4.setSettings(settings4)
        rule4.setDescription("Parcelles possession = True et couleur fonc√©")
        root_rule.appendChild(rule4)

        # Appliquer le syst√®me d‚Äô√©tiquettes
        labeling = QgsRuleBasedLabeling(root_rule)
        layer.setLabeling(labeling)
        layer.setLabelsEnabled(True)
        layer.triggerRepaint()

    def display_point(self, point, button):
        self.last_position = self.dlg.pos()
        self.dlg.hide()

        # V√©rifie que la couche active est valide
        layer = get_valid_active_layer(self.dlg)
        if not layer:
            return

        # Recherche de la g√©om√©trie cliqu√©e
        req = QgsFeatureRequest().setFilterRect(QgsGeometry.fromPointXY(QgsPointXY(point.x(), point.y())).boundingBox())
        entites = layer.getFeatures(req)

        for e in entites:
            # Stocke l'ID de l'entit√© cliqu√©e
            self.current_feature_id = e.id()

            # Affiche les coordonn√©es
            self.dlg.coordClick.setText(f"{point.x()}, {point.y()}")

            # Affiche la section, num√©ro, indice
            indice = e['indice_parc'] if 'indice_parc' in e.fields().names() and e['indice_parc'] else ''
            self.dlg.coord2.setText(e['section'] + e['numero'] + indice)

            # Affiche la surface
            self.dlg.surface.setText(str(e['SURFACE']) + ' ares')

            # Remplit les champs texte simples
            safe_set_text(self.dlg.annee, e['annee'])
            safe_set_text(self.dlg.totalPlants, e['totalplants'])
            safe_set_text(self.dlg.editTerrain, e['Terrain'])
            safe_set_text(self.dlg.editAcces, e['Acces'])
            safe_set_text(self.dlg.editRemTerrain, e['RemTerrain'])

            # M√©morisation des valeurs Terrain et Acc√®s
            terrain = e['Terrain']
            acces = e['Acces']

            start = time.time()
            self.remplir_combobox_terrain_acces(terrain, acces)
            self.remplir_combobox_terrain_acces()
            end = time.time()
            print(f"remplir_combobox_terrain_acces took {end - start:.3f} seconds")

            # Affiche la possession
            self.dlg.checkBoxPossession.setChecked(bool(e['Possession']))

            # Affiche le libell√© du type de parcellaire
            type_parc_val = e['typeParc']
            libelle = TYPE_PARC_LIBELLES.get(type_parc_val, "Inconnu")
            self.dlg.libelleTypeParc.setText(libelle)

            # Couleur de fond en fonction du type
            layer = get_valid_active_layer(self.dlg)
            if not layer:
                return
            couleur = get_fill_color_from_layer(layer, type_parc_val)
            self.dlg.colorFrame.setStyleSheet(f"background-color: {couleur}; border: 1px solid black;")

            # Coordonn√©es du voisin
            safe_set_text(self.dlg.nomProp, e['nom_Voisin'])
            safe_set_text(self.dlg.lineAdress, e['adresse_Voisin'])
            safe_set_text(self.dlg.lineMail, e['mail_Voisin'])
            safe_set_text(self.dlg.lineTel, e['tel_Voisin'])

            # Champs modifiables
            self.remplir_champs_modifiables(e)

            # Possession : influe sur les onglets visibles
            self.is_proprietaire = bool(e['possession'])
            self.dlg.checkBoxSaisie.setChecked(False)
            self.update_tab_visibility()

            # Infos plantations
            txt_plants, txt_taux = self.build_liste_arbres(e)
            self.dlg.plantation.setText(txt_plants)
            self.dlg.taux.setText(txt_taux)

            # Connexions pour la checkbox de possession
            try:
                self.dlg.checkBoxPossession.toggled.disconnect()
            except TypeError:
                pass
            self.dlg.checkBoxPossession.toggled.connect(self.handle_possession_toggle)

            # Connexion pour la case √† cocher de saisie
            try:
                self.dlg.checkBoxSaisie.toggled.disconnect(self.handle_checkbox_toggle)
            except TypeError:
                pass
            self.dlg.checkBoxSaisie.toggled.connect(self.handle_checkbox_toggle)

            # Initialisation des combos de saisie
            fid = self.current_feature_id
            if not layer or fid is None:
                return
            feature = layer.getFeature(fid)

            for prefix, combo_base in [("plant", "comboPlant"), ("Tvx", "comboTvx"), ("Trait", "comboTrait"),
                                       ("Prev", "comboPrev")]:
                self.init_saisie_combos(prefix, combo_base, feature)


            # Initialisation des combos de l√©gendes modifiables
            self.init_combo_modif_legend(feature)

            # Infos compl√©mentaires
            self.dlg.travauxListe.setText(self.build_travaux_dates(e))
            self.dlg.travauxRq.setText(self.build_travaux_remarques(e))
            self.dlg.traitListe.setText(self.build_trait_dates(e))
            self.dlg.traitRq.setText(self.build_trait_remarques(e))
            self.dlg.prevListe.setText(self.build_prev_dates(e))
            self.dlg.prevRq.setText(self.build_prev_remarques(e))

        # Positionnement de la fen√™tre
        if self.first_show:
            qr = self.dlg.frameGeometry()
            cp = self.dlg.screen().availableGeometry().center()
            qr.moveCenter(cp)
            self.dlg.move(qr.topLeft())
            self.first_show = False
        elif self.last_position is not None:
            self.dlg.move(self.last_position)

        # Mode lecture seule ou √©dition
        self.dlg.checkEditProp.setChecked(False)
        self.toggle_edit_mode()

        # Connexion √† la checkbox de saisie
        try:
            self.dlg.checkBoxSaisie.toggled.disconnect()
        except TypeError:
            pass
        self.dlg.checkBoxSaisie.toggled.connect(self.handle_checkbox_toggle)

        # Connexion √† la checkbox de configuration
        try:
            self.dlg.checkBoxConfig.toggled.disconnect()
        except Exception:
            pass
        self.dlg.checkBoxConfig.toggled.connect(self.update_tab_visibility)

        # Initialisation du bouton "fill ring"
        self.init_ring_fill_button()

        # Mise √† jour finale des onglets
        self.dlg.checkBoxConfig.blockSignals(True)
        self.dlg.checkBoxConfig.setChecked(False)
        self.dlg.checkBoxConfig.blockSignals(False)
        self.update_tab_visibility()

        # Affichage de la fen√™tre
        self.dlg.show()

    # Affichage des r√©sultats de l'onglet Analyses dans les champs
    def data_analyse(self):
        if not hasattr(self, 'analyse_results') or not self.analyse_results:
            # Pas encore de r√©sultats : afficher rien ou message
            return

        results = self.analyse_results

        self.dlg.lineTotalSurface.setText(str(results.get("surface_forestiere", "")))
        self.dlg.lineTotalSurfaceF.setText(str(results.get("surface_friche", "")))
        self.dlg.lineTotalRepiq.setText(str(results.get("total_plants", "")))
        self.dlg.textEditAnalyse.setPlainText(results.get("types_parcelles", ""))
        self.dlg.textEditEssences.setPlainText(results.get("types_essences", ""))
        self.dlg.textEditRegroup.setPlainText(results.get("regroupement", ""))
        self.dlg.lineTotalParcelles.setText(str(results.get("nb_parcelles", "")))
